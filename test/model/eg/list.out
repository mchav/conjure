length :: [Int] -> Int
-- testing 60 combinations of argument values
-- looking through 2/2 candidates of size 1
-- looking through 1/1 candidates of size 2
-- looking through 2/2 candidates of size 3
-- looking through 3/3 candidates of size 4
-- looking through 5/5 candidates of size 5
-- looking through 11/11 candidates of size 6
-- looking through 22/22 candidates of size 7
-- looking through 51/51 candidates of size 8
-- looking through 95/95 candidates of size 9
length xs  =  if null xs then 0 else 1 + length (tail xs)

reverse :: [Int] -> [Int]
-- testing 60 combinations of argument values
-- looking through 2/2 candidates of size 1
-- looking through 4/4 candidates of size 2
-- looking through 9/9 candidates of size 3
-- looking through 24/24 candidates of size 4
-- looking through 65/65 candidates of size 5
-- looking through 215/215 candidates of size 6
-- looking through 673/673 candidates of size 7
-- looking through 2178/2178 candidates of size 8
-- looking through 7134/7134 candidates of size 9
-- looking through 23667/23667 candidates of size 10
-- looking through 79362/79362 candidates of size 11
reverse xs  =  if null xs then [] else reverse (tail xs) ++ unit (head xs)

sort :: [Int] -> [Int]
-- testing 60 combinations of argument values
-- looking through 2/2 candidates of size 1
-- looking through 4/4 candidates of size 2
-- looking through 6/6 candidates of size 3
-- looking through 12/12 candidates of size 4
-- looking through 31/31 candidates of size 5
-- looking through 98/98 candidates of size 6
-- looking through 287/287 candidates of size 7
-- looking through 792/792 candidates of size 8
-- looking through 2204/2204 candidates of size 9
-- looking through 6392/6392 candidates of size 10
sort xs  =  if null xs then xs else insert (head xs) (sort (tail xs))

(++) :: [Int] -> [Int] -> [Int]
-- testing 60 combinations of argument values
-- looking through 3/3 candidates of size 1
-- looking through 3/3 candidates of size 2
-- looking through 12/12 candidates of size 3
-- looking through 39/39 candidates of size 4
-- looking through 83/83 candidates of size 5
-- looking through 290/290 candidates of size 6
-- looking through 1013/1013 candidates of size 7
-- looking through 3482/3482 candidates of size 8
-- looking through 11243/11243 candidates of size 9
-- looking through 36527/36527 candidates of size 10
-- looking through 125199/125199 candidates of size 11
xs ++ ys  =  if null xs then ys else head xs:(tail xs ++ ys)

length :: [Int] -> Int
-- testing 60 combinations of argument values
-- looking through 2/2 candidates of size 1
-- looking through 1/1 candidates of size 2
-- looking through 1/1 candidates of size 3
-- looking through 4/4 candidates of size 4
-- looking through 2/2 candidates of size 5
-- looking through 10/10 candidates of size 6
length xs  =  foldr (const (1 +)) 0 xs

reverse :: [Int] -> [Int]
-- testing 60 combinations of argument values
-- looking through 2/2 candidates of size 1
-- looking through 2/2 candidates of size 2
-- looking through 1/1 candidates of size 3
-- looking through 5/5 candidates of size 4
-- looking through 1/1 candidates of size 5
-- looking through 17/17 candidates of size 6
-- looking through 37/37 candidates of size 7
reverse xs  =  foldr (flip (++) . unit) [] xs

sort :: [Int] -> [Int]
-- testing 60 combinations of argument values
-- looking through 2/2 candidates of size 1
-- looking through 2/2 candidates of size 2
-- looking through 0/0 candidates of size 3
-- looking through 2/2 candidates of size 4
sort xs  =  foldr insert [] xs

(++) :: [Int] -> [Int] -> [Int]
-- testing 60 combinations of argument values
-- looking through 3/3 candidates of size 1
-- looking through 0/0 candidates of size 2
-- looking through 9/9 candidates of size 3
-- looking through 4/4 candidates of size 4
xs ++ ys  =  foldr (:) ys xs

