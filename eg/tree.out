leftmost :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 3/3 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 4 candidates of size 6
-- looking through 16 candidates of size 7
leftmost Leaf  =  undefined
leftmost (Node t1 x t2)  =  if nil t1 then x else leftmost t1

rightmost :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 3/3 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 4 candidates of size 6
-- looking through 16 candidates of size 7
rightmost Leaf  =  undefined
rightmost (Node t1 x t2)  =  if nil t2 then x else rightmost t2

size :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 4/8 rules
-- looking through 2 candidates of size 1
-- looking through 4 candidates of size 2
-- looking through 5 candidates of size 3
-- looking through 19 candidates of size 4
-- looking through 35 candidates of size 5
-- looking through 66 candidates of size 6
-- looking through 163 candidates of size 7
-- looking through 311 candidates of size 8
size Leaf  =  0
size (Node t1 x t2)  =  size t1 + (size t2 + 1)

height :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 49/65 rules
-- looking through 3 candidates of size 1
-- looking through 9 candidates of size 2
-- looking through 8 candidates of size 3
-- looking through 59 candidates of size 4
-- looking through 114 candidates of size 5
-- looking through 388 candidates of size 6
-- looking through 1255 candidates of size 7
-- looking through 3833 candidates of size 8
height Leaf  =  -1
height (Node t1 x t2)  =  1 + max (height t1) (height t2)

mem :: Int -> Tree -> Bool
-- testing 60 combinations of argument values
-- pruning with 11/17 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 34 candidates of size 8
-- looking through 0 candidates of size 9
-- looking through 0 candidates of size 10
-- looking through 0 candidates of size 11
-- looking through 184 candidates of size 12
mem x Leaf  =  False
mem x (Node t1 y t2)  =  mem x t1 || (x == y || mem x t2)

insert :: Int -> Tree -> Tree
-- testing 60 combinations of argument values
-- pruning with 6/7 rules
-- looking through 2 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 10 candidates of size 4
-- looking through 21 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 118 candidates of size 7
-- looking through 239 candidates of size 8
-- looking through 216 candidates of size 9
-- looking through 2204 candidates of size 10
-- looking through 3651 candidates of size 11
-- looking through 8280 candidates of size 12
cannot conjure

