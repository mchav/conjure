leftmost :: Tree -> Int
-- testing 360 combinations of argument values
-- pruning with 3/3 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 4 candidates of size 6
-- looking through 16 candidates of size 7
-- tested 9 candidates
leftmost Leaf  =  undefined
leftmost (Node t1 x t2)  =  if nil t1 then x else leftmost t1

rightmost :: Tree -> Int
-- testing 360 combinations of argument values
-- pruning with 3/3 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 4 candidates of size 6
-- looking through 16 candidates of size 7
-- tested 18 candidates
rightmost Leaf  =  undefined
rightmost (Node t1 x t2)  =  if nil t2 then x else rightmost t2

size :: Tree -> Int
-- testing 360 combinations of argument values
-- pruning with 4/8 rules
-- looking through 2 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 8 candidates of size 4
-- looking through 17 candidates of size 5
-- looking through 28 candidates of size 6
-- looking through 73 candidates of size 7
-- looking through 136 candidates of size 8
-- tested 219 candidates
size Leaf  =  0
size (Node t1 x t2)  =  size t1 + (size t2 + 1)

height :: Tree -> Int
-- testing 360 combinations of argument values
-- pruning with 49/65 rules
-- looking through 3 candidates of size 1
-- looking through 3 candidates of size 2
-- looking through 4 candidates of size 3
-- looking through 17 candidates of size 4
-- looking through 38 candidates of size 5
-- looking through 144 candidates of size 6
-- looking through 464 candidates of size 7
-- looking through 1801 candidates of size 8
-- tested 819 candidates
height Leaf  =  -1
height (Node t1 x t2)  =  max (height t1) (height t2) + 1

mem :: Int -> Tree -> Bool
-- testing 360 combinations of argument values
-- pruning with 11/17 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 34 candidates of size 8
-- looking through 0 candidates of size 9
-- looking through 0 candidates of size 10
-- looking through 0 candidates of size 11
-- looking through 184 candidates of size 12
-- tested 107 candidates
mem x Leaf  =  False
mem x (Node t1 y t2)  =  mem x t1 || (x == y || mem x t2)

member :: Int -> Tree -> Bool
-- testing 360 combinations of argument values
-- pruning with 20/30 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 8 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 60 candidates of size 8
-- looking through 120 candidates of size 9
-- looking through 0 candidates of size 10
-- looking through 452 candidates of size 11
-- looking through 424 candidates of size 12
-- looking through 3840 candidates of size 13
-- looking through 3840 candidates of size 14
-- looking through 18272 candidates of size 15
-- tested 18059 candidates
member x Leaf  =  False
member x (Node t1 y t2)  =  x == y || (if x < y then member x t1 else member x t2)

insert :: Int -> Tree -> Tree
-- testing 360 combinations of argument values
-- pruning with 6/7 rules
-- looking through 2 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 10 candidates of size 4
-- looking through 21 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 118 candidates of size 7
-- looking through 239 candidates of size 8
-- looking through 216 candidates of size 9
-- looking through 2204 candidates of size 10
-- looking through 3651 candidates of size 11
-- looking through 8280 candidates of size 12
-- tested 14743 candidates
cannot conjure

before :: Int -> Tree -> Tree
-- testing 360 combinations of argument values
-- pruning with 5/6 rules
-- looking through 2 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 10 candidates of size 4
-- looking through 18 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 112 candidates of size 7
-- looking through 216 candidates of size 8
-- looking through 216 candidates of size 9
-- looking through 2096 candidates of size 10
-- looking through 3384 candidates of size 11
-- looking through 8064 candidates of size 12
-- tested 14120 candidates
cannot conjure

before :: Int -> Tree -> Tree
-- testing 360 combinations of argument values
-- pruning with 1/2 rules
-- looking through 2 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 10 candidates of size 4
-- looking through 18 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 94 candidates of size 7
-- looking through 312 candidates of size 8
-- looking through 72 candidates of size 9
-- looking through 2096 candidates of size 10
-- looking through 6336 candidates of size 11
-- looking through 3888 candidates of size 12
-- looking through 52696 candidates of size 13
-- looking through 146448 candidates of size 14
-- looking through 155520 candidates of size 15
-- tested 266809 candidates
before x Leaf  =  Leaf
before x (Node t1 y t2)  =  case (y `compare` x) (Node t1 y (before x t2)) t1 (before x t1)

