leftmost :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 3/3 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 4 candidates of size 6
-- looking through 16 candidates of size 7
leftmost Leaf  =  undefined
leftmost (Node x y z)  =  if nil x then y else leftmost x

rightmost :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 3/3 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 4 candidates of size 6
-- looking through 16 candidates of size 7
rightmost Leaf  =  undefined
rightmost (Node x y z)  =  if nil z then y else rightmost z

size :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 4/8 rules
-- looking through 2 candidates of size 1
-- looking through 4 candidates of size 2
-- looking through 5 candidates of size 3
-- looking through 27 candidates of size 4
-- looking through 83 candidates of size 5
-- looking through 358 candidates of size 6
-- looking through 1435 candidates of size 7
-- looking through 5963 candidates of size 8
size Leaf  =  0
size (Node x y z)  =  size x + (size z + 1)

height :: Tree -> Int
-- testing 60 combinations of argument values
-- pruning with 49/65 rules
-- looking through 3 candidates of size 1
-- looking through 9 candidates of size 2
-- looking through 8 candidates of size 3
-- looking through 71 candidates of size 4
-- looking through 186 candidates of size 5
-- looking through 948 candidates of size 6
-- looking through 3943 candidates of size 7
-- looking through 18069 candidates of size 8
height Leaf  =  -1
height (Node x y z)  =  1 + max (height x) (height z)

mem :: Int -> Tree -> Bool
-- testing 60 combinations of argument values
-- pruning with 11/17 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 34 candidates of size 8
-- looking through 0 candidates of size 9
-- looking through 0 candidates of size 10
-- looking through 0 candidates of size 11
-- looking through 184 candidates of size 12
mem x Leaf  =  False
mem x (Node y z x')  =  mem x y || (x == z || mem x x')

insert :: Int -> Tree -> Bool
-- testing 60 combinations of argument values
-- pruning with 9/10 rules
-- looking through 0 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 4 candidates of size 3
-- looking through 16 candidates of size 4
-- looking through 40 candidates of size 5
-- looking through 156 candidates of size 6
-- looking through 705 candidates of size 7
-- looking through 3245 candidates of size 8
-- looking through 15025 candidates of size 9
cannot conjure

