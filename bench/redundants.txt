Redundant candidates for: foo :: Int -> Int
  pruning with 15/35 rules
  [3,3,8,9,21,27] candidates
  63/71 unique candidates
  8/71 redundant candidates

rules:
x * y == x + y
x * y == y + x
x - x == 0
x + 0 == x
0 + x == x
x - 0 == x
(x + y) + z == x + (y + z)
(x + y) + z == y + (x + z)
x - (y - z) == z + (x - y)
(x - y) - z == x - (y + z)
(x - y) - z == x - (z + y)
(x + y) - z == x + (y - z)
(x + y) - z == y + (x - z)
x + (y - x) == y
(x - y) + y == x
equations:
y + x == x + y
y + (x + z) == x + (y + z)
z + (x + y) == x + (y + z)
z + (y + x) == x + (y + z)
y + (x - z) == x + (y - z)
(x - z) + y == x + (y - z)
(z - y) + x == (x - y) + z
y - (x + y) == 0 - x
y - (y + x) == 0 - x
z - (y + z) == x - (x + y)
z - (y + z) == x - (y + x)
z - (z + y) == x - (x + y)
z - (z + y) == x - (y + x)
x + (0 - y) == x - y
(0 - y) + x == x - y
x - (x + 1) == 0 - 1
x - (1 + x) == 0 - 1
y - (y + 1) == x - (x + 1)
y - (y + 1) == x - (1 + x)
y - (1 + y) == x - (1 + x)

class of 3 equivalent candidates:

    foo x  =  0 - x

    foo x  =  x - (x + x)

    foo x  =  1 - (x + 1)


class of 2 equivalent candidates:

    foo x  =  1 - x

    foo x  =  1 + (0 - x)


class of 2 equivalent candidates:

    foo 0  =  0
    foo x  =  1 - x

    foo 0  =  0
    foo x  =  1 + (0 - x)


class of 3 equivalent candidates:

    foo 0  =  1
    foo x  =  0 - x

    foo 0  =  1
    foo x  =  x - (x + x)

    foo 0  =  1
    foo x  =  1 - (x + 1)


class of 2 equivalent candidates:

    foo x  =  x + (x + 1)

    foo x  =  1 + (x + x)


class of 2 equivalent candidates:

    foo 0  =  0
    foo x  =  x + (x + 1)

    foo 0  =  0
    foo x  =  1 + (x + x)



Redundant candidates for: ? :: Int -> Int -> Int
  pruning with 10/23 rules
  [3,7,22,49,112,276] candidates
  395/469 unique candidates
  74/469 redundant candidates

rules:
x * y == x + y
x * y == y + x
x + 0 == x
0 + x == x
dec (x + y) == x + dec y
dec (x + y) == y + dec x
dec (x + y) == dec x + y
dec (x + y) == dec y + x
(x + y) + z == x + (y + z)
(x + y) + z == y + (x + z)
equations:
y + x == x + y
y + dec x == x + dec y
dec x + y == x + dec y
dec y + x == dec x + y
x + dec 0 == dec x
dec 0 + x == dec x
y + (x + z) == x + (y + z)
z + (x + y) == x + (y + z)
z + (y + x) == x + (y + z)
y + dec (dec x) == x + dec (dec y)
dec (dec x) + y == x + dec (dec y)
x + dec (dec 0) == dec (dec x)
dec (dec 0) + x == dec (dec x)

class of 4 equivalent candidates:

    x ? y  =  x + dec y

    x ? y  =  y + dec x

    x ? 0  =  dec x
    x ? y  =  x + dec y

    0 ? x  =  dec x
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    x ? 0  =  x
    x ? y  =  0 ? dec y

    x ? 0  =  x
    x ? y  =  dec y ? dec y


class of 3 equivalent candidates:

    x ? 0  =  x
    x ? y  =  dec x ? y

    x ? 0  =  x
    x ? y  =  dec (dec x) ? y

    x ? 0  =  x
    x ? y  =  dec (dec x ? y)


class of 3 equivalent candidates:

    0 ? x  =  x
    x ? y  =  x ? dec y

    0 ? x  =  x
    x ? y  =  x ? dec (dec y)

    0 ? x  =  x
    x ? y  =  dec (x ? dec y)


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? y  =  dec x ? 0

    0 ? x  =  x
    x ? y  =  dec x ? dec x


class of 2 equivalent candidates:

    x ? y  =  x + (x + y)

    x ? y  =  y + (x + x)


class of 2 equivalent candidates:

    x ? y  =  x + (y + y)

    x ? y  =  y + (x + y)


class of 2 equivalent candidates:

    x ? y  =  x + dec (dec x)

    x ? y  =  dec x + dec x


class of 3 equivalent candidates:

    x ? y  =  x + dec (dec y)

    x ? y  =  y + dec (dec x)

    x ? y  =  dec x + dec y


class of 2 equivalent candidates:

    x ? y  =  y + dec (dec y)

    x ? y  =  dec y + dec y


class of 2 equivalent candidates:

    x ? 0  =  x
    x ? y  =  x + dec y

    x ? 0  =  x
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    x ? 0  =  0
    x ? y  =  x + dec y

    x ? 0  =  0
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? y  =  x + dec y

    0 ? x  =  x
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? y  =  x + dec y

    0 ? x  =  0
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    x ? 0  =  x
    x ? y  =  dec x ? dec y

    x ? 0  =  x
    x ? y  =  dec (x ? dec y)


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? y  =  dec x ? dec y

    0 ? x  =  x
    x ? y  =  dec (dec x ? y)


class of 3 equivalent candidates:

    x ? 0  =  0
    x ? y  =  dec (x ? dec y)

    x ? 0  =  0
    x ? y  =  dec (y ? dec y)

    x ? 0  =  0
    x ? y  =  dec (0 ? dec y)


class of 3 equivalent candidates:

    0 ? x  =  0
    x ? y  =  dec (dec x ? x)

    0 ? x  =  0
    x ? y  =  dec (dec x ? y)

    0 ? x  =  0
    x ? y  =  dec (dec x ? 0)


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? 0  =  0
    x ? y  =  x ? dec y

    0 ? x  =  x
    x ? 0  =  0
    x ? y  =  y ? dec y


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? 0  =  x
    x ? y  =  dec x ? x

    0 ? x  =  0
    x ? 0  =  x
    x ? y  =  dec x ? y


class of 2 equivalent candidates:

    x ? y  =  x + dec (dec (dec x))

    x ? y  =  dec x + dec (dec x)


class of 4 equivalent candidates:

    x ? y  =  x + dec (dec (dec y))

    x ? y  =  y + dec (dec (dec x))

    x ? y  =  dec x + dec (dec y)

    x ? y  =  dec y + dec (dec x)


class of 2 equivalent candidates:

    x ? y  =  x + (x + dec x)

    x ? y  =  dec x + (x + x)


class of 5 equivalent candidates:

    x ? y  =  x + (x + dec y)

    x ? y  =  x + (y + dec x)

    x ? y  =  y + (x + dec x)

    x ? y  =  dec x + (x + y)

    x ? y  =  dec y + (x + x)


class of 5 equivalent candidates:

    x ? y  =  x + (y + dec y)

    x ? y  =  y + (x + dec y)

    x ? y  =  y + (y + dec x)

    x ? y  =  dec x + (y + y)

    x ? y  =  dec y + (x + y)


class of 2 equivalent candidates:

    x ? y  =  y + dec (dec (dec y))

    x ? y  =  dec y + dec (dec y)


class of 2 equivalent candidates:

    x ? y  =  y + (y + dec y)

    x ? y  =  dec y + (y + y)


class of 2 equivalent candidates:

    x ? 0  =  x
    x ? y  =  x + (x + y)

    x ? 0  =  x
    x ? y  =  y + (x + x)


class of 2 equivalent candidates:

    x ? 0  =  x
    x ? y  =  x + dec (dec x)

    x ? 0  =  x
    x ? y  =  dec x + dec x


class of 3 equivalent candidates:

    x ? 0  =  x
    x ? y  =  x + dec (dec y)

    x ? 0  =  x
    x ? y  =  y + dec (dec x)

    x ? 0  =  x
    x ? y  =  dec x + dec y


class of 2 equivalent candidates:

    x ? 0  =  x
    x ? y  =  y + dec (dec y)

    x ? 0  =  x
    x ? y  =  dec y + dec y


class of 2 equivalent candidates:

    x ? 0  =  0
    x ? y  =  x + (x + y)

    x ? 0  =  0
    x ? y  =  y + (x + x)


class of 2 equivalent candidates:

    x ? 0  =  0
    x ? y  =  x + (y + y)

    x ? 0  =  0
    x ? y  =  y + (x + y)


class of 2 equivalent candidates:

    x ? 0  =  0
    x ? y  =  x + dec (dec x)

    x ? 0  =  0
    x ? y  =  dec x + dec x


class of 3 equivalent candidates:

    x ? 0  =  0
    x ? y  =  x + dec (dec y)

    x ? 0  =  0
    x ? y  =  y + dec (dec x)

    x ? 0  =  0
    x ? y  =  dec x + dec y


class of 2 equivalent candidates:

    x ? 0  =  0
    x ? y  =  y + dec (dec y)

    x ? 0  =  0
    x ? y  =  dec y + dec y


class of 2 equivalent candidates:

    x ? 0  =  x + dec (dec x)
    x ? y  =  x

    x ? 0  =  dec x + dec x
    x ? y  =  x


class of 2 equivalent candidates:

    x ? 0  =  x + dec (dec x)
    x ? y  =  y

    x ? 0  =  dec x + dec x
    x ? y  =  y


class of 2 equivalent candidates:

    x ? 0  =  x + dec (dec x)
    x ? y  =  0

    x ? 0  =  dec x + dec x
    x ? y  =  0


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? y  =  x + (y + y)

    0 ? x  =  x
    x ? y  =  y + (x + y)


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? y  =  x + dec (dec x)

    0 ? x  =  x
    x ? y  =  dec x + dec x


class of 3 equivalent candidates:

    0 ? x  =  x
    x ? y  =  x + dec (dec y)

    0 ? x  =  x
    x ? y  =  y + dec (dec x)

    0 ? x  =  x
    x ? y  =  dec x + dec y


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? y  =  y + dec (dec y)

    0 ? x  =  x
    x ? y  =  dec y + dec y


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? y  =  x + (x + y)

    0 ? x  =  0
    x ? y  =  y + (x + x)


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? y  =  x + (y + y)

    0 ? x  =  0
    x ? y  =  y + (x + y)


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? y  =  x + dec (dec x)

    0 ? x  =  0
    x ? y  =  dec x + dec x


class of 3 equivalent candidates:

    0 ? x  =  0
    x ? y  =  x + dec (dec y)

    0 ? x  =  0
    x ? y  =  y + dec (dec x)

    0 ? x  =  0
    x ? y  =  dec x + dec y


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? y  =  y + dec (dec y)

    0 ? x  =  0
    x ? y  =  dec y + dec y


class of 2 equivalent candidates:

    0 ? x  =  x + dec (dec x)
    x ? y  =  x

    0 ? x  =  dec x + dec x
    x ? y  =  x


class of 2 equivalent candidates:

    0 ? x  =  x + dec (dec x)
    x ? y  =  y

    0 ? x  =  dec x + dec x
    x ? y  =  y


class of 2 equivalent candidates:

    0 ? x  =  x + dec (dec x)
    x ? y  =  0

    0 ? x  =  dec x + dec x
    x ? y  =  0


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? 0  =  x
    x ? y  =  x + dec y

    0 ? x  =  x
    x ? 0  =  x
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    0 ? x  =  x
    x ? 0  =  0
    x ? y  =  x + dec y

    0 ? x  =  x
    x ? 0  =  0
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? 0  =  x
    x ? y  =  x + dec y

    0 ? x  =  0
    x ? 0  =  x
    x ? y  =  y + dec x


class of 2 equivalent candidates:

    0 ? x  =  0
    x ? 0  =  0
    x ? y  =  x + dec y

    0 ? x  =  0
    x ? 0  =  0
    x ? y  =  y + dec x



Redundant candidates for: goo :: [Int] -> [Int]
  pruning with 4/4 rules
  [2,1,1,2,4,7] candidates
  15/17 unique candidates
  2/17 redundant candidates

rules:
xs ++ [] == xs
[] ++ xs == xs
(xs ++ ys) ++ zs == xs ++ (ys ++ zs)
(x:xs) ++ ys == x:(xs ++ ys)

class of 2 equivalent candidates:

    goo xs  =  xs

    goo []  =  []
    goo (x:xs)  =  x:goo xs


class of 2 equivalent candidates:

    goo xs  =  []

    goo []  =  []
    goo (x:xs)  =  goo xs ++ goo xs



Redundant candidates for: ?? :: [Int] -> [Int] -> [Int]
  pruning with 4/4 rules
  [3,7,15,45,123,299] candidates
  354/492 unique candidates
  138/492 redundant candidates

rules:
xs ++ [] == xs
[] ++ xs == xs
(xs ++ ys) ++ zs == xs ++ (ys ++ zs)
(x:xs) ++ ys == x:(xs ++ ys)

class of 9 equivalent candidates:

    xs ?? ys  =  xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ++ [] ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ++ [] ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  [] ?? xs ++ xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  [] ?? ys ++ xs

    [] ?? xs  =  []
    (x:xs) ?? ys  =  x:xs ?? xs

    [] ?? xs  =  []
    (x:xs) ?? ys  =  x:xs ?? ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  x:xs ?? []


class of 9 equivalent candidates:

    xs ?? ys  =  ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  x:xs ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  x:ys ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  x:[] ?? ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ++ xs ?? []

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ++ ys ?? []

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? [] ++ ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? [] ++ ys


class of 6 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  []

    xs ?? []  =  xs
    xs ?? (x:ys)  =  ys ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  [] ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  [] ?? ys

    [] ?? xs  =  []
    (x:xs) ?? []  =  x:xs
    (x:xs) ?? (y:ys)  =  []

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (ys ++ ys) ?? ys


class of 6 equivalent candidates:

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs

    [] ?? xs  =  []
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  x:xs

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ++ [] ?? xs

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ++ [] ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  [] ?? xs ++ xs

    xs ?? []  =  []
    xs ?? (x:ys)  =  [] ?? ys ++ xs


class of 3 equivalent candidates:

    xs ?? []  =  []
    xs ?? (x:ys)  =  ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  xs ?? ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  [] ?? ys


class of 11 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  []

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? xs

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? []

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? []

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs ?? xs
    (x:xs) ?? (y:ys)  =  []

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs ?? []
    (x:xs) ?? (y:ys)  =  []

    [] ?? xs  =  xs
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  xs ?? xs

    [] ?? xs  =  xs
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  xs ?? []

    [] ?? xs  =  xs
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  ys ?? ys

    [] ?? xs  =  xs
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  ys ?? []

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? (xs ++ xs)


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs

    [] ?? []  =  []
    [] ?? (x:xs)  =  [] ?? xs
    (x:xs) ?? ys  =  xs


class of 7 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs ?? []
    (x:xs) ?? ys  =  ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  [] ?? xs
    (x:xs) ?? ys  =  ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ++ xs ?? []

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ++ ys ?? []

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ?? [] ++ ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ?? [] ++ ys


class of 2 equivalent candidates:

    xs ?? ys  =  xs ++ xs

    xs ?? []  =  xs ++ xs
    xs ?? (x:ys)  =  xs ?? ys


class of 4 equivalent candidates:

    xs ?? ys  =  xs ++ ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  x:xs ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ++ (x:ys)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  x:(xs ++ ys)


class of 4 equivalent candidates:

    xs ?? ys  =  ys ++ xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  x:xs ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  x:(ys ++ xs)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ++ (x:xs)


class of 2 equivalent candidates:

    xs ?? ys  =  ys ++ ys

    [] ?? xs  =  xs ++ xs
    (x:xs) ?? ys  =  xs ?? ys


class of 3 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  []

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ?? xs

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys ?? ys


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  xs

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs ?? []
    (x:xs) ?? (y:ys)  =  xs


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  ys

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs ?? []
    (x:xs) ?? (y:ys)  =  ys


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  [] ?? xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys


class of 5 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  []

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ?? xs

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys ?? ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs ?? xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  []

    [] ?? []  =  []
    [] ?? (x:xs)  =  [] ?? xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  []


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  xs

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs ?? []
    (x:xs) ?? (y:ys)  =  xs


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? []  =  []
    (x:xs) ?? (y:ys)  =  ys

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs ?? []
    (x:xs) ?? (y:ys)  =  ys


class of 2 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs ?? xs
    (x:xs) ?? ys  =  ys


class of 6 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  []

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  xs ?? xs

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  xs ?? []

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  ys ?? []

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs ?? xs
    (x:xs) ?? (y:ys)  =  []

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs ?? []
    (x:xs) ?? (y:ys)  =  []


class of 4 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (xs ++ xs) ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ++ xs ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ?? xs ++ xs


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? xs

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ?? ys


class of 4 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? (ys ++ ys)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ++ ys ?? ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? ys ++ ys


class of 3 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  x:ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  x:ys ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  x:[] ?? ys


class of 4 equivalent candidates:

    xs ?? []  =  xs ++ xs
    xs ?? (x:ys)  =  []

    xs ?? []  =  xs ++ xs
    xs ?? (x:ys)  =  ys ?? ys

    xs ?? []  =  xs ++ xs
    xs ?? (x:ys)  =  [] ?? xs

    xs ?? []  =  xs ++ xs
    xs ?? (x:ys)  =  [] ?? ys


class of 3 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  x:xs

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  x:xs ?? xs

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  x:xs ?? []


class of 4 equivalent candidates:

    [] ?? xs  =  xs ++ xs
    (x:xs) ?? ys  =  []

    [] ?? xs  =  xs ++ xs
    (x:xs) ?? ys  =  xs ?? xs

    [] ?? xs  =  xs ++ xs
    (x:xs) ?? ys  =  xs ?? []

    [] ?? xs  =  xs ++ xs
    (x:xs) ?? ys  =  ys ?? []


class of 3 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  []

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ?? xs

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys ?? ys


class of 3 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? ys  =  ys ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  ys ++ xs ?? xs

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ?? xs ++ ys


class of 2 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs ?? xs
    (x:xs) ?? ys  =  xs

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs ?? []
    (x:xs) ?? ys  =  xs


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ++ ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ++ ys ?? []


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys ++ xs

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? [] ++ xs


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ++ ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ++ ys ?? []


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys ++ xs

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ?? [] ++ xs


class of 3 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (x:xs) ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  [x] ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  x:xs ?? xs


class of 2 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (x:ys) ?? xs

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? (x:xs)


class of 2 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (x:ys) ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  [x] ?? ys


class of 4 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (xs ++ ys) ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (ys ++ xs) ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  ys ++ xs ?? xs

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ?? xs ++ ys


class of 2 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (xs ++ ys) ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ++ ys ?? ys


class of 2 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  (ys ++ xs) ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  ys ?? ys ++ xs


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? (x:xs)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? [x]


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? (xs ++ ys)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? xs ++ ys


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? (ys ++ xs)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ++ xs ?? xs


class of 3 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? (x:ys)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? [x]

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  x:ys ?? ys


class of 4 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? (xs ++ ys)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? (ys ++ xs)

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ++ ys ?? ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ?? ys ++ xs


class of 2 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ++ xs ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  xs ?? ys ++ xs


class of 2 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  ys ++ ys ?? ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  ys ++ [] ?? ys


class of 2 equivalent candidates:

    xs ?? []  =  xs
    xs ?? (x:ys)  =  ys ?? ys ++ ys

    xs ?? []  =  xs
    xs ?? (x:ys)  =  [] ?? ys ++ ys


class of 4 equivalent candidates:

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ++ xs ?? xs

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ?? xs ++ xs

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ++ ys ?? ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ?? ys ++ ys


class of 2 equivalent candidates:

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ++ xs ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ?? ys ++ xs


class of 3 equivalent candidates:

    xs ?? []  =  []
    xs ?? (x:ys)  =  ys ++ xs ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  ys ++ ys ?? ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  ys ++ [] ?? ys


class of 3 equivalent candidates:

    xs ?? []  =  []
    xs ?? (x:ys)  =  xs ?? ys ++ ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  ys ?? ys ++ ys

    xs ?? []  =  []
    xs ?? (x:ys)  =  [] ?? ys ++ ys


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ++ xs ?? xs

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ++ xs ?? []


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  ys ++ xs ?? ys

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? ys ++ ys


class of 2 equivalent candidates:

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? xs ++ xs

    [] ?? xs  =  xs
    (x:xs) ?? ys  =  xs ?? [] ++ xs


class of 3 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ++ xs ?? xs

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ++ xs ?? ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ++ xs ?? []


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ++ ys ?? ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ?? ys ++ xs


class of 2 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? ys  =  ys ++ xs ?? ys

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ?? ys ++ ys


class of 3 equivalent candidates:

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ?? xs ++ xs

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ?? ys ++ xs

    [] ?? xs  =  []
    (x:xs) ?? ys  =  xs ?? [] ++ xs


class of 2 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ?? ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys ?? xs


class of 2 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  xs ?? []

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  [] ?? xs


class of 2 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys ?? []

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  [] ?? ys


class of 2 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  xs ?? xs
    (x:xs) ?? (y:ys)  =  xs

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs
    (x:xs) ?? []  =  [] ?? xs
    (x:xs) ?? (y:ys)  =  xs


class of 2 equivalent candidates:

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs ?? xs
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys

    [] ?? []  =  []
    [] ?? (x:xs)  =  xs ?? []
    (x:xs) ?? []  =  xs
    (x:xs) ?? (y:ys)  =  ys



Redundant candidates for: ton :: Bool -> Bool
  pruning with 39/49 rules
  [3,2,0,0,0,0] candidates
  4/5 unique candidates
  1/5 redundant candidates

rules:
not False == True
not True == False
p && p == p
p || p == p
not (not p) == p
p && False == False
p && True == p
False && p == False
True && p == p
p || False == p
p || True == True
False || p == p
True || p == True
not (p && q) == not p || not q
not (p && q) == not q || not p
not (p || q) == not p && not q
not (p || q) == not q && not p
p && not p == False
not p && p == False
p || not p == True
not p || p == True
(p && q) && r == p && (q && r)
(p && q) && r == q && (p && r)
(p || q) || r == p || (q || r)
(p || q) || r == q || (p || r)
p && (p && q) == p && q
p && (q && p) == p && q
p && (q && p) == q && p
p || (p || q) == p || q
p || (q || p) == p || q
p || (q || p) == q || p
p && (p || q) == p
p && (q || p) == p
(p || q) && p == p
(p || q) && q == q
p || p && q == p
p || q && p == p
p && q || p == p
p && q || q == q
equations:
q && p == p && q
q || p == p || q
q && (p && r) == p && (q && r)
r && (p && q) == p && (q && r)
r && (q && p) == p && (q && r)
q || (p || r) == p || (q || r)
r || (p || q) == p || (q || r)
r || (q || p) == p || (q || r)
(r || q) && p == p && (q || r)
r && q || p == p || q && r

class of 2 equivalent candidates:

    ton p  =  not p

    ton False  =  True
    ton True  =  False



Redundant candidates for: &| :: Bool -> Bool -> Bool
  pruning with 39/49 rules
  [4,12,20,6,2,16] candidates
  16/60 unique candidates
  44/60 redundant candidates

rules:
not False == True
not True == False
p && p == p
p || p == p
not (not p) == p
p && False == False
p && True == p
False && p == False
True && p == p
p || False == p
p || True == True
False || p == p
True || p == True
not (p && q) == not p || not q
not (p && q) == not q || not p
not (p || q) == not p && not q
not (p || q) == not q && not p
p && not p == False
not p && p == False
p || not p == True
not p || p == True
(p && q) && r == p && (q && r)
(p && q) && r == q && (p && r)
(p || q) || r == p || (q || r)
(p || q) || r == q || (p || r)
p && (p && q) == p && q
p && (q && p) == p && q
p && (q && p) == q && p
p || (p || q) == p || q
p || (q || p) == p || q
p || (q || p) == q || p
p && (p || q) == p
p && (q || p) == p
(p || q) && p == p
(p || q) && q == q
p || p && q == p
p || q && p == p
p && q || p == p
p && q || q == q
equations:
q && p == p && q
q || p == p || q
q && (p && r) == p && (q && r)
r && (p && q) == p && (q && r)
r && (q && p) == p && (q && r)
q || (p || r) == p || (q || r)
r || (p || q) == p || (q || r)
r || (q || p) == p || (q || r)
(r || q) && p == p && (q || r)
r && q || p == p || q && r

class of 5 equivalent candidates:

    p &| q  =  False

    p &| q  =  p && (q && not p)

    p &| q  =  q && (p && not q)

    p &| q  =  not p && (p && q)

    p &| q  =  not q && (p && q)


class of 5 equivalent candidates:

    p &| q  =  True

    p &| q  =  p || (q || not p)

    p &| q  =  q || (p || not q)

    p &| q  =  not p || (p || q)

    p &| q  =  not q || (p || q)


class of 2 equivalent candidates:

    p &| q  =  not p

    False &| p  =  True
    True &| p  =  False


class of 4 equivalent candidates:

    p &| q  =  not q

    p &| False  =  True
    p &| True  =  False

    False &| p  =  not p
    True &| False  =  True
    True &| True  =  False

    False &| False  =  True
    False &| True  =  False
    True &| p  =  not p


class of 5 equivalent candidates:

    p &| False  =  p
    p &| True  =  False

    False &| p  =  False
    True &| p  =  not p

    False &| p  =  False
    True &| False  =  True
    True &| True  =  False

    p &| q  =  p && not q

    p &| q  =  not q && (p || q)


class of 5 equivalent candidates:

    p &| False  =  p
    p &| True  =  True

    False &| p  =  p
    True &| p  =  True

    p &| q  =  p || q

    p &| q  =  p || q && not p

    p &| q  =  q || p && not q


class of 5 equivalent candidates:

    p &| False  =  False
    p &| True  =  p

    False &| p  =  False
    True &| p  =  p

    p &| q  =  p && q

    p &| q  =  p && (q || not p)

    p &| q  =  q && (p || not q)


class of 5 equivalent candidates:

    p &| False  =  True
    p &| True  =  p

    False &| p  =  not p
    True &| p  =  True

    False &| False  =  True
    False &| True  =  False
    True &| p  =  True

    p &| q  =  p || not q

    p &| q  =  not q || p && q


class of 4 equivalent candidates:

    False &| p  =  p
    True &| p  =  False

    p &| False  =  False
    p &| True  =  not p

    p &| q  =  q && not p

    p &| q  =  not p && (p || q)


class of 4 equivalent candidates:

    False &| p  =  True
    True &| p  =  p

    p &| False  =  not p
    p &| True  =  True

    p &| q  =  q || not p

    p &| q  =  not p || p && q


class of 3 equivalent candidates:

    p &| False  =  p
    p &| True  =  not p

    False &| p  =  p
    True &| p  =  not p

    False &| p  =  p
    True &| False  =  True
    True &| True  =  False


class of 4 equivalent candidates:

    p &| False  =  True
    p &| True  =  not p

    False &| p  =  True
    True &| p  =  not p

    False &| p  =  True
    True &| False  =  True
    True &| True  =  False

    p &| q  =  not p || not q


class of 3 equivalent candidates:

    p &| False  =  not p
    p &| True  =  p

    False &| p  =  not p
    True &| p  =  p

    False &| False  =  True
    False &| True  =  False
    True &| p  =  p


class of 4 equivalent candidates:

    p &| False  =  not p
    p &| True  =  False

    False &| p  =  not p
    True &| p  =  False

    False &| False  =  True
    False &| True  =  False
    True &| p  =  False

    p &| q  =  not p && not q



