gps1 :: Int -> Float -> Float
-- testing 4 combinations of argument values
-- pruning with 2/6 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 1 candidates of size 3
-- looking through 2 candidates of size 4
gps1 x y  =  fromIntegral x + y

gps2 :: Int -> Maybe [Char]
-- testing 6 combinations of argument values
-- pruning with 9/17 rules
-- looking through 1 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 4 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 8 candidates of size 5
-- looking through 12 candidates of size 6
-- looking through 38 candidates of size 7
-- looking through 48 candidates of size 8
-- looking through 112 candidates of size 9
-- looking through 144 candidates of size 10
-- looking through 176 candidates of size 11
-- looking through 704 candidates of size 12
-- looking through 1856 candidates of size 13
gps2 x  =  if 2000 <= x then Just "large" else (if x < 1000 then Just "small" else Nothing)

gps3 :: Int -> Int -> Int -> [Int]
-- testing 2 combinations of argument values
-- pruning with 11/33 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 64 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 1536 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 26127 candidates of size 8
gps3 x y z  =  enumFromThenTo x (x + z) (y - 1)

gps3 :: Int -> Int -> Int -> [Int]
-- testing 2 combinations of argument values
-- pruning with 6/18 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 18 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 108 candidates of size 7
-- looking through 36 candidates of size 8
cannot conjure

gps4 :: [Char] -> [Char] -> [Char] -> Bool
-- testing 9 combinations of argument values
-- pruning with 11/15 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 6 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 0 candidates of size 8
-- looking through 162 candidates of size 9
-- looking through 30 candidates of size 10
-- looking through 30 candidates of size 11
gps4 cs ds es  =  length cs < length ds && length ds < length es

gps5 :: [Char] -> [Char]
-- testing 5 combinations of argument values
-- pruning with 2/6 rules
-- looking through 2 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 5 candidates of size 5
-- looking through 13 candidates of size 6
cannot conjure

gps6 :: Int -> Int
-- testing 60 combinations of argument values
-- pruning with 16/18 rules
-- looking through 4 candidates of size 1
-- looking through 9 candidates of size 2
-- looking through 30 candidates of size 3
-- looking through 125 candidates of size 4
-- looking through 415 candidates of size 5
-- looking through 1602 candidates of size 6
cannot conjure

