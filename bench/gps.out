gps1 :: Int -> Float -> Float
-- testing 4 combinations of argument values
-- pruning with 1/2 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 1 candidates of size 3
-- looking through 2 candidates of size 4
gps1 x y  =  fromIntegral x + y

gps2 :: Int -> Maybe [Char]
-- testing 6 combinations of argument values
-- pruning with 9/17 rules
-- looking through 1 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 4 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 8 candidates of size 5
-- looking through 12 candidates of size 6
-- looking through 38 candidates of size 7
-- looking through 48 candidates of size 8
-- looking through 112 candidates of size 9
-- looking through 144 candidates of size 10
-- looking through 176 candidates of size 11
-- looking through 704 candidates of size 12
-- looking through 1856 candidates of size 13
gps2 x  =  if 2000 <= x then Just "large" else (if x < 1000 then Just "small" else Nothing)

gps3 :: Int -> Int -> Int -> [Int]
-- testing 2 combinations of argument values
-- pruning with 11/33 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 64 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 1536 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 26991 candidates of size 8
gps3 x y z  =  enumFromThenTo x (x + z) (y - 1)

gps3 :: Int -> Int -> Int -> [Int]
-- testing 2 combinations of argument values
-- pruning with 6/18 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 18 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 108 candidates of size 7
-- looking through 36 candidates of size 8
cannot conjure

gps4 :: [Char] -> [Char] -> [Char] -> Bool
-- testing 9 combinations of argument values
-- pruning with 11/15 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 6 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 0 candidates of size 8
-- looking through 162 candidates of size 9
-- looking through 30 candidates of size 10
-- looking through 30 candidates of size 11
gps4 cs ds es  =  length cs < length ds && length ds < length es

gps5 :: [Char] -> [Char]
-- testing 5 combinations of argument values
-- pruning with 2/3 rules
-- looking through 2 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 5 candidates of size 5
-- looking through 13 candidates of size 6
cannot conjure

gps6 :: Int -> Int
-- testing 9 combinations of argument values
-- pruning with 16/18 rules
-- looking through 4 candidates of size 1
-- looking through 9 candidates of size 2
-- looking through 33 candidates of size 3
-- looking through 146 candidates of size 4
-- looking through 609 candidates of size 5
-- looking through 2561 candidates of size 6
cannot conjure

gps7 :: [Char] -> ([Char],Int)
-- testing 4 combinations of argument values
-- pruning with 5/10 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 1 candidates of size 4
-- looking through 2 candidates of size 5
-- looking through 7 candidates of size 6
-- looking through 16 candidates of size 7
-- looking through 39 candidates of size 8
-- looking through 88 candidates of size 9
-- looking through 201 candidates of size 10
-- looking through 442 candidates of size 11
gps7 cs  =  (init (unlines (words cs)),length (filter (not . isSpace) cs))

gps8 :: [Char] -> [Char] -> [(Int,Char,Char)]
-- testing 3 combinations of argument values
-- pruning with 0/0 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
cannot conjure

gps9 :: Int -> [Int]
-- testing 3 combinations of argument values
-- pruning with 13/14 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 4 candidates of size 3
-- looking through 4 candidates of size 4
-- looking through 10 candidates of size 5
-- looking through 25 candidates of size 6
-- looking through 35 candidates of size 7
-- looking through 87 candidates of size 8
-- looking through 150 candidates of size 9
-- looking through 272 candidates of size 10
gps9 x  =  filter even (filter (x >) (map sq [1..x]))

wallisNext :: Ratio Integer -> Ratio Integer
-- testing 6 combinations of argument values
-- pruning with 37/64 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 15 candidates of size 4
-- looking through 4 candidates of size 5
-- looking through 118 candidates of size 6
-- looking through 5 candidates of size 7
-- looking through 1001 candidates of size 8
wallisNext (x % y)  =  (y + 1) % (x + 1)

gps10 :: Int -> Ratio Integer
-- testing 6 combinations of argument values
-- pruning with 3/4 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 3 candidates of size 4
-- looking through 2 candidates of size 5
-- looking through 5 candidates of size 6
-- looking through 8 candidates of size 7
-- looking through 13 candidates of size 8
gps10 x  =  product (take x (iterate wallisNext (2 % 3)))

gps11 :: [[Char]] -> [Int]
-- testing 4 combinations of argument values
-- pruning with 1/1 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 1 candidates of size 3
-- looking through 1 candidates of size 4
gps11 css  =  reverse (map length css)

gps11 :: [[Char]] -> [Int]
-- testing 4 combinations of argument values
-- pruning with 4/4 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 1 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 1 candidates of size 5
-- looking through 2 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 2 candidates of size 8
gps11 []  =  []
gps11 (cs:css)  =  gps11 css ++ [length cs]

gps12 :: [Int] -> Int
-- testing 6 combinations of argument values
-- pruning with 13/27 rules
-- looking through 2 candidates of size 1
-- looking through 5 candidates of size 2
-- looking through 5 candidates of size 3
-- looking through 16 candidates of size 4
-- looking through 26 candidates of size 5
-- looking through 71 candidates of size 6
-- looking through 160 candidates of size 7
-- looking through 432 candidates of size 8
-- looking through 1166 candidates of size 9
-- looking through 3187 candidates of size 10
-- looking through 9282 candidates of size 11
gps12 xs  =  (length xs - fromJust (findIndex (0 ==) (reverse xs))) - 1

gps13 :: [Ratio Integer] -> Ratio Integer
-- testing 3 combinations of argument values
-- pruning with 4/8 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 10 candidates of size 4
-- looking through 15 candidates of size 5
-- looking through 56 candidates of size 6
-- looking through 125 candidates of size 7
-- looking through 449 candidates of size 8
gps13 qs  =  foldr (+) 0 qs / fromIntegral (length qs)

odd :: Int -> Bool
-- testing 6 combinations of argument values
-- pruning with 12/13 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 7 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 71 candidates of size 5
odd x  =  x `mod` 2 /= 0

gps14 :: [Int] -> Int
-- testing 3 combinations of argument values
-- pruning with 1/1 rules
-- looking through 0 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 1 candidates of size 4
gps14 xs  =  length (filter odd xs)

gps14 :: [Int] -> Int
-- testing 3 combinations of argument values
-- pruning with 39/58 rules
-- looking through 3 candidates of size 1
-- looking through 9 candidates of size 2
-- looking through 7 candidates of size 3
-- looking through 58 candidates of size 4
-- looking through 66 candidates of size 5
-- looking through 600 candidates of size 6
-- looking through 1034 candidates of size 7
gps14 []  =  0
gps14 (x:xs)  =  x `mod` 2 + gps14 xs

gps15 :: [Int] -> [Int] -> Bool
-- testing 5 combinations of argument values
-- pruning with 3/7 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 8 candidates of size 4
gps15 xs ys  =  reverse xs == ys

gps16 :: [Char] -> [Char] -> Bool
-- testing 6 combinations of argument values
-- pruning with 3/3 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 2 candidates of size 5
gps16 cs ds  =  sort cs `isSubsequenceOf` sort ds

gps17 :: Int -> Int
-- testing 4 combinations of argument values
-- pruning with 13/33 rules
-- looking through 2 candidates of size 1
-- looking through 3 candidates of size 2
-- looking through 8 candidates of size 3
-- looking through 19 candidates of size 4
-- looking through 50 candidates of size 5
-- looking through 139 candidates of size 6
-- looking through 400 candidates of size 7
-- looking through 1171 candidates of size 8
gps17 0  =  0
gps17 x  =  x * x + gps17 (dec x)

gps18 :: [Int] -> [Int] -> [Int]
-- testing 3 combinations of argument values
-- pruning with 2/6 rules
-- looking through 3 candidates of size 1
-- looking through 8 candidates of size 2
-- looking through 11 candidates of size 3
-- looking through 44 candidates of size 4
-- looking through 116 candidates of size 5
-- looking through 92 candidates of size 6
-- looking through 791 candidates of size 7
-- looking through 220 candidates of size 8
-- looking through 4632 candidates of size 9
gps18 [] []  =  []
gps18 [] (x:xs)  =  xs
gps18 (x:xs) []  =  xs
gps18 (x:xs) (y:ys)  =  x + y:gps18 xs ys

gps18 :: [Int] -> [Int] -> [Int]
-- testing 3 combinations of argument values
-- pruning with 2/7 rules
-- looking through 2 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 12 candidates of size 4
gps18 xs ys  =  zipWith (+) xs ys

gps19 :: Int -> [Char] -> [Char]
-- testing 2 combinations of argument values
-- pruning with 0/0 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
cannot conjure

isVowel :: Char -> Bool
-- testing 11 combinations of argument values
-- pruning with 0/0 rules
-- looking through 2 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 8 candidates of size 4
-- looking through 8 candidates of size 5
-- looking through 14 candidates of size 6
-- looking through 26 candidates of size 7
-- looking through 26 candidates of size 8
-- looking through 34 candidates of size 9
-- looking through 34 candidates of size 10
-- looking through 58 candidates of size 11
-- looking through 44 candidates of size 12
-- looking through 44 candidates of size 13
-- looking through 30 candidates of size 14
-- looking through 30 candidates of size 15
-- looking through 62 candidates of size 16
isVowel 'a'  =  True
isVowel 'e'  =  True
isVowel 'i'  =  True
isVowel 'o'  =  True
isVowel 'u'  =  True
isVowel c  =  False

pig1 :: [Char] -> [Char]
-- testing 4 combinations of argument values
-- pruning with 5/5 rules
-- looking through 2 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 5 candidates of size 3
-- looking through 8 candidates of size 4
-- looking through 14 candidates of size 5
-- looking through 28 candidates of size 6
-- looking through 47 candidates of size 7
-- looking through 126 candidates of size 8
-- looking through 201 candidates of size 9
-- looking through 631 candidates of size 10
-- looking through 1069 candidates of size 11
-- looking through 3495 candidates of size 12
-- looking through 6382 candidates of size 13
-- looking through 20409 candidates of size 14
pig1 ""  =  "ay"
pig1 (c:cs)  =  if isVowel c then (c:cs) ++ "ay" else cs ++ (c:"ay")

gps20c :: [Char] -> [Char]
-- testing 2 combinations of argument values
-- pruning with 1/1 rules
-- looking through 1 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 3 candidates of size 4
-- looking through 5 candidates of size 5
gps20c cs  =  unwords (map pig1 (words cs))

gps21 :: [Int] -> [Int]
-- testing 4 combinations of argument values
-- pruning with 4/4 rules
-- looking through 2 candidates of size 1
-- looking through 1 candidates of size 2
-- looking through 3 candidates of size 3
-- looking through 6 candidates of size 4
-- looking through 5 candidates of size 5
-- looking through 13 candidates of size 6
-- looking through 9 candidates of size 7
-- looking through 30 candidates of size 8
-- looking through 25 candidates of size 9
-- looking through 65 candidates of size 10
gps21 []  =  []
gps21 (x:xs)  =  (if x < 0 then 0 else x):gps21 xs

gps22 :: [Char] -> Int
-- testing 4 combinations of argument values
-- pruning with 5/9 rules
-- looking through 1 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 2 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 4 candidates of size 6
gps22 ""  =  0
gps22 (c:cs)  =  scrabble1 c + gps22 cs

gps23 :: [Char] -> ([(Int,Int)],Int,Double)
-- testing 1 combinations of argument values
-- pruning with 0/0 rules
-- looking through 0 candidates of size 1
-- looking through 0 candidates of size 2
cannot conjure

gps24 :: [Char] -> Char
-- testing 4 combinations of argument values
-- pruning with 15/19 rules
-- looking through 1 candidates of size 1
-- looking through 2 candidates of size 2
-- looking through 4 candidates of size 3
-- looking through 3 candidates of size 4
-- looking through 9 candidates of size 5
-- looking through 19 candidates of size 6
-- looking through 40 candidates of size 7
-- looking through 97 candidates of size 8
-- looking through 286 candidates of size 9
-- looking through 739 candidates of size 10
gps24 cs  =  chr (ord ' ' + sum (map ord cs) `mod` 64)

gps25 :: Int -> [Int]
-- testing 4 combinations of argument values
-- pruning with 0/0 rules
-- looking through 0 candidates of size 1
cannot conjure

gps26 :: Int -> Int -> Int -> Int -> Int -> Char
-- testing 5 combinations of argument values
-- pruning with 4/4 rules
-- looking through 5 candidates of size 1
-- looking through 0 candidates of size 2
cannot conjure

gps27 :: Int -> Int -> Int -> Int
-- testing 3 combinations of argument values
-- pruning with 14/18 rules
-- looking through 3 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 0 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 0 candidates of size 5
-- looking through 36 candidates of size 6
-- looking through 0 candidates of size 7
-- looking through 0 candidates of size 8
-- looking through 0 candidates of size 9
-- looking through 180 candidates of size 10
-- looking through 2592 candidates of size 11
gps27 x y z  =  if x < y then (if y < z then y else z) else x

gps28 :: Int -> Int -> Int -> Int -> Int
-- testing 5 combinations of argument values
-- pruning with 6/10 rules
-- looking through 4 candidates of size 1
-- looking through 0 candidates of size 2
-- looking through 12 candidates of size 3
-- looking through 0 candidates of size 4
-- looking through 24 candidates of size 5
-- looking through 0 candidates of size 6
-- looking through 72 candidates of size 7
gps28 x y z x'  =  x `min` (y `min` (z `min` x'))

